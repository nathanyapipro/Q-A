"""All input for the create `Question` mutation."""
input CreateQuestionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Question` to be created by this mutation."""
  question: QuestionInput!
}

"""The output of our create `Question` mutation."""
type CreateQuestionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Question` that was created by this mutation."""
  question: Question

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Question`."""
  user: User

  """Reads a single `Status` that is related to this `Question`."""
  status: Status

  """An edge for our `Question`. May be used by Relay 1."""
  questionEdge(
    """The method to use when ordering `Question`."""
    orderBy: [QuestionsOrderBy!] = PRIMARY_KEY_ASC
  ): QuestionsEdge
}

"""All input for the create `Tag` mutation."""
input CreateTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Tag` to be created by this mutation."""
  tag: TagInput!
}

"""The output of our create `Tag` mutation."""
type CreateTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Tag` that was created by this mutation."""
  tag: Tag

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Tag`. May be used by Relay 1."""
  tagEdge(
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = PRIMARY_KEY_ASC
  ): TagsEdge
}

"""All input for the `createUser` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  username: String
  password: String
  roleId: Int
}

"""The output of our `createUser` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Role` that is related to this `User`."""
  role: Role

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = PRIMARY_KEY_ASC
  ): UsersEdge
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""All input for the `deleteQuestionById` mutation."""
input DeleteQuestionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """unique identifier for the question."""
  id: Int!
}

"""All input for the `deleteQuestion` mutation."""
input DeleteQuestionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Question` to be deleted.
  """
  nodeId: ID!
}

"""The output of our delete `Question` mutation."""
type DeleteQuestionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Question` that was deleted by this mutation."""
  question: Question
  deletedQuestionId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Question`."""
  user: User

  """Reads a single `Status` that is related to this `Question`."""
  status: Status

  """An edge for our `Question`. May be used by Relay 1."""
  questionEdge(
    """The method to use when ordering `Question`."""
    orderBy: [QuestionsOrderBy!] = PRIMARY_KEY_ASC
  ): QuestionsEdge
}

"""All input for the `deleteTagById` mutation."""
input DeleteTagByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """unique identifier for the tag."""
  id: Int!
}

"""All input for the `deleteTagByName` mutation."""
input DeleteTagByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """name of the tag."""
  name: String!
}

"""All input for the `deleteTag` mutation."""
input DeleteTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Tag` to be deleted.
  """
  nodeId: ID!
}

"""The output of our delete `Tag` mutation."""
type DeleteTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Tag` that was deleted by this mutation."""
  tag: Tag
  deletedTagId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Tag`. May be used by Relay 1."""
  tagEdge(
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = PRIMARY_KEY_ASC
  ): TagsEdge
}

"""All input for the `deleteUserById` mutation."""
input DeleteUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """unique identifier for the user."""
  id: Int!
}

"""All input for the `deleteUserByUsername` mutation."""
input DeleteUserByUsernameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """public-facing username (or 'handle') of the user."""
  username: String!
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be deleted.
  """
  nodeId: ID!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was deleted by this mutation."""
  user: User
  deletedUserId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Role` that is related to this `User`."""
  role: Role

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = PRIMARY_KEY_ASC
  ): UsersEdge
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Included in the specified list."""
  in: [Int!]

  """Not included in the specified list."""
  notIn: [Int!]

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""All input for the `loginAnonymous` mutation."""
input LoginAnonymousInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  username: String!
}

"""The output of our `loginAnonymous` mutation."""
type LoginAnonymousPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Role` that is related to this `User`."""
  role: Role

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = PRIMARY_KEY_ASC
  ): UsersEdge
}

"""All input for the `login` mutation."""
input LoginInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  username: String!
  password: String
}

"""The output of our `login` mutation."""
type LoginPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Role` that is related to this `User`."""
  role: Role

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = PRIMARY_KEY_ASC
  ): UsersEdge
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `Question`."""
  createQuestion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateQuestionInput!
  ): CreateQuestionPayload

  """Creates a single `Tag`."""
  createTag(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTagInput!
  ): CreateTagPayload

  """Updates a single `Question` using its globally unique id and a patch."""
  updateQuestion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateQuestionInput!
  ): UpdateQuestionPayload

  """Updates a single `Question` using a unique key and a patch."""
  updateQuestionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateQuestionByIdInput!
  ): UpdateQuestionPayload

  """Updates a single `Tag` using its globally unique id and a patch."""
  updateTag(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTagInput!
  ): UpdateTagPayload

  """Updates a single `Tag` using a unique key and a patch."""
  updateTagById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTagByIdInput!
  ): UpdateTagPayload

  """Updates a single `Tag` using a unique key and a patch."""
  updateTagByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTagByNameInput!
  ): UpdateTagPayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserByIdInput!
  ): UpdateUserPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUserByUsername(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserByUsernameInput!
  ): UpdateUserPayload

  """Deletes a single `Question` using its globally unique id."""
  deleteQuestion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteQuestionInput!
  ): DeleteQuestionPayload

  """Deletes a single `Question` using a unique key."""
  deleteQuestionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteQuestionByIdInput!
  ): DeleteQuestionPayload

  """Deletes a single `Tag` using its globally unique id."""
  deleteTag(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTagInput!
  ): DeleteTagPayload

  """Deletes a single `Tag` using a unique key."""
  deleteTagById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTagByIdInput!
  ): DeleteTagPayload

  """Deletes a single `Tag` using a unique key."""
  deleteTagByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTagByNameInput!
  ): DeleteTagPayload

  """Deletes a single `User` using its globally unique id."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload

  """Deletes a single `User` using a unique key."""
  deleteUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserByIdInput!
  ): DeleteUserPayload

  """Deletes a single `User` using a unique key."""
  deleteUserByUsername(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserByUsernameInput!
  ): DeleteUserPayload

  """Creates a user account."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """
  Returns a user that matches the username/password combo, or null on failure.
  """
  login(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: LoginInput!
  ): LoginPayload

  """Returns a user that matches the crypt username, or null on failure."""
  loginAnonymous(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: LoginAnonymousInput!
  ): LoginAnonymousPayload
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Question`."""
  questions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Question`."""
    orderBy: [QuestionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: QuestionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: QuestionFilter
  ): QuestionsConnection

  """Reads and enables pagination through a set of `Role`."""
  roles(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Role`."""
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RoleCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RoleFilter
  ): RolesConnection

  """Reads and enables pagination through a set of `Status`."""
  statuses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Status`."""
    orderBy: [StatusesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StatusCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: StatusFilter
  ): StatusesConnection

  """Reads and enables pagination through a set of `Tag`."""
  tags(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TagFilter
  ): TagsConnection
  questionById(id: Int!): Question
  roleById(id: Int!): Role
  roleByName(name: String!): Role
  statusById(id: Int!): Status
  statusByName(name: String!): Status
  tagById(id: Int!): Tag
  tagByName(name: String!): Tag
  userById(id: Int!): User
  userByUsername(username: String!): User

  """Reads a single `Question` using its globally unique `ID`."""
  question(
    """The globally unique `ID` to be used in selecting a single `Question`."""
    nodeId: ID!
  ): Question

  """Reads a single `Role` using its globally unique `ID`."""
  role(
    """The globally unique `ID` to be used in selecting a single `Role`."""
    nodeId: ID!
  ): Role

  """Reads a single `Status` using its globally unique `ID`."""
  status(
    """The globally unique `ID` to be used in selecting a single `Status`."""
    nodeId: ID!
  ): Status

  """Reads a single `Tag` using its globally unique `ID`."""
  tag(
    """The globally unique `ID` to be used in selecting a single `Tag`."""
    nodeId: ID!
  ): Tag

  """Reads a single `User` using its globally unique `ID`."""
  user(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User
}

"""question of a question in the application."""
type Question implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """unique identifier for the question."""
  id: Int!

  """content of the question."""
  content: String!

  """owner of the question."""
  userId: Int!

  """metadata of the question"""
  meta: JSON!

  """status of the question"""
  statusId: Int!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `User` that is related to this `Question`."""
  user: User

  """Reads a single `Status` that is related to this `Question`."""
  status: Status
}

"""
A condition to be used against `Question` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input QuestionCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `userId` field."""
  userId: Int

  """Checks for equality with the object’s `statusId` field."""
  statusId: Int
}

"""
A filter to be used against `Question` object types. All fields are combined with a logical ‘and.’
"""
input QuestionFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `userId` field."""
  userId: IntFilter

  """Filter by the object’s `statusId` field."""
  statusId: IntFilter

  """Checks for all expressions in this list."""
  and: [QuestionFilter!]

  """Checks for any expressions in this list."""
  or: [QuestionFilter!]

  """Negates the expression."""
  not: QuestionFilter
}

"""An input for mutations affecting `Question`"""
input QuestionInput {
  """unique identifier for the question."""
  id: Int

  """content of the question."""
  content: String!

  """owner of the question."""
  userId: Int!

  """metadata of the question"""
  meta: JSON

  """status of the question"""
  statusId: Int!
  createdAt: Datetime
  updatedAt: Datetime
}

"""
Represents an update to a `Question`. Fields that are set will be updated.
"""
input QuestionPatch {
  """unique identifier for the question."""
  id: Int

  """content of the question."""
  content: String

  """owner of the question."""
  userId: Int

  """metadata of the question"""
  meta: JSON

  """status of the question"""
  statusId: Int
  createdAt: Datetime
  updatedAt: Datetime
}

"""A connection to a list of `Question` values."""
type QuestionsConnection {
  """A list of `Question` objects."""
  nodes: [Question!]!

  """
  A list of edges which contains the `Question` and cursor to aid in pagination.
  """
  edges: [QuestionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Question` you could get from the connection."""
  totalCount: Int
}

"""A `Question` edge in the connection."""
type QuestionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Question` at the end of the edge."""
  node: Question!
}

"""Methods to use when ordering `Question`."""
enum QuestionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  STATUS_ID_ASC
  STATUS_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A role in the application."""
type Role implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """unique identifier for the role."""
  id: Int!

  """name of the role."""
  name: String!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UsersConnection!
}

"""
A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RoleCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""
A filter to be used against `Role` object types. All fields are combined with a logical ‘and.’
"""
input RoleFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Checks for all expressions in this list."""
  and: [RoleFilter!]

  """Checks for any expressions in this list."""
  or: [RoleFilter!]

  """Negates the expression."""
  not: RoleFilter
}

"""A connection to a list of `Role` values."""
type RolesConnection {
  """A list of `Role` objects."""
  nodes: [Role!]!

  """
  A list of edges which contains the `Role` and cursor to aid in pagination.
  """
  edges: [RolesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Role` you could get from the connection."""
  totalCount: Int
}

"""A `Role` edge in the connection."""
type RolesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Role` at the end of the edge."""
  node: Role!
}

"""Methods to use when ordering `Role`."""
enum RolesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A status of a question in the application."""
type Status implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """unique identifier for the status."""
  id: Int!

  """name of the status."""
  name: String!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads and enables pagination through a set of `Question`."""
  questions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Question`."""
    orderBy: [QuestionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: QuestionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: QuestionFilter
  ): QuestionsConnection!
}

"""
A condition to be used against `Status` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input StatusCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""A connection to a list of `Status` values."""
type StatusesConnection {
  """A list of `Status` objects."""
  nodes: [Status!]!

  """
  A list of edges which contains the `Status` and cursor to aid in pagination.
  """
  edges: [StatusesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Status` you could get from the connection."""
  totalCount: Int
}

"""A `Status` edge in the connection."""
type StatusesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Status` at the end of the edge."""
  node: Status!
}

"""Methods to use when ordering `Status`."""
enum StatusesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A filter to be used against `Status` object types. All fields are combined with a logical ‘and.’
"""
input StatusFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Checks for all expressions in this list."""
  and: [StatusFilter!]

  """Checks for any expressions in this list."""
  or: [StatusFilter!]

  """Negates the expression."""
  not: StatusFilter
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any
  single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_)
  matches any single character; a percent sign (%) matches any sequence of zero
  or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches
  any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_)
  matches any single character; a percent sign (%) matches any sequence of zero
  or more characters.
  """
  notLikeInsensitive: String

  """
  Matches the specified pattern using the SQL standard's definition of a regular expression.
  """
  similarTo: String

  """
  Does not match the specified pattern using the SQL standard's definition of a regular expression.
  """
  notSimilarTo: String
}

"""tag of a question in the application."""
type Tag implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """unique identifier for the tag."""
  id: Int!

  """name of the tag."""
  name: String!

  """color of the tag."""
  color: String!

  """determines if the tag is available."""
  isEnabled: Boolean!
  createdAt: Datetime!
  updatedAt: Datetime!
}

"""
A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TagCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""
A filter to be used against `Tag` object types. All fields are combined with a logical ‘and.’
"""
input TagFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Checks for all expressions in this list."""
  and: [TagFilter!]

  """Checks for any expressions in this list."""
  or: [TagFilter!]

  """Negates the expression."""
  not: TagFilter
}

"""An input for mutations affecting `Tag`"""
input TagInput {
  """unique identifier for the tag."""
  id: Int

  """name of the tag."""
  name: String!

  """color of the tag."""
  color: String!

  """determines if the tag is available."""
  isEnabled: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

"""Represents an update to a `Tag`. Fields that are set will be updated."""
input TagPatch {
  """unique identifier for the tag."""
  id: Int

  """name of the tag."""
  name: String

  """color of the tag."""
  color: String

  """determines if the tag is available."""
  isEnabled: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

"""A connection to a list of `Tag` values."""
type TagsConnection {
  """A list of `Tag` objects."""
  nodes: [Tag!]!

  """
  A list of edges which contains the `Tag` and cursor to aid in pagination.
  """
  edges: [TagsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Tag` you could get from the connection."""
  totalCount: Int
}

"""A `Tag` edge in the connection."""
type TagsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Tag` at the end of the edge."""
  node: Tag!
}

"""Methods to use when ordering `Tag`."""
enum TagsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""All input for the `updateQuestionById` mutation."""
input UpdateQuestionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Question` being updated.
  """
  patch: QuestionPatch!

  """unique identifier for the question."""
  id: Int!
}

"""All input for the `updateQuestion` mutation."""
input UpdateQuestionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Question` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Question` being updated.
  """
  patch: QuestionPatch!
}

"""The output of our update `Question` mutation."""
type UpdateQuestionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Question` that was updated by this mutation."""
  question: Question

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Question`."""
  user: User

  """Reads a single `Status` that is related to this `Question`."""
  status: Status

  """An edge for our `Question`. May be used by Relay 1."""
  questionEdge(
    """The method to use when ordering `Question`."""
    orderBy: [QuestionsOrderBy!] = PRIMARY_KEY_ASC
  ): QuestionsEdge
}

"""All input for the `updateTagById` mutation."""
input UpdateTagByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Tag` being updated.
  """
  patch: TagPatch!

  """unique identifier for the tag."""
  id: Int!
}

"""All input for the `updateTagByName` mutation."""
input UpdateTagByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Tag` being updated.
  """
  patch: TagPatch!

  """name of the tag."""
  name: String!
}

"""All input for the `updateTag` mutation."""
input UpdateTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Tag` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Tag` being updated.
  """
  patch: TagPatch!
}

"""The output of our update `Tag` mutation."""
type UpdateTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Tag` that was updated by this mutation."""
  tag: Tag

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Tag`. May be used by Relay 1."""
  tagEdge(
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = PRIMARY_KEY_ASC
  ): TagsEdge
}

"""All input for the `updateUserById` mutation."""
input UpdateUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!

  """unique identifier for the user."""
  id: Int!
}

"""All input for the `updateUserByUsername` mutation."""
input UpdateUserByUsernameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!

  """public-facing username (or 'handle') of the user."""
  username: String!
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Role` that is related to this `User`."""
  role: Role

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = PRIMARY_KEY_ASC
  ): UsersEdge
}

"""A user who can log in to the application."""
type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """unique identifier for the user."""
  id: Int!

  """public-facing username (or 'handle') of the user."""
  username: String!

  """role of the user."""
  roleId: Int!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `Role` that is related to this `User`."""
  role: Role

  """Reads and enables pagination through a set of `Question`."""
  questions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Question`."""
    orderBy: [QuestionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: QuestionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: QuestionFilter
  ): QuestionsConnection!
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `username` field."""
  username: String

  """Checks for equality with the object’s `roleId` field."""
  roleId: Int
}

"""
A filter to be used against `User` object types. All fields are combined with a logical ‘and.’
"""
input UserFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `username` field."""
  username: StringFilter

  """Filter by the object’s `roleId` field."""
  roleId: IntFilter

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Checks for any expressions in this list."""
  or: [UserFilter!]

  """Negates the expression."""
  not: UserFilter
}

"""
Represents an update to a `User`. Fields that are set will be updated.
"""
input UserPatch {
  """unique identifier for the user."""
  id: Int

  """public-facing username (or 'handle') of the user."""
  username: String

  """role of the user."""
  roleId: Int
  createdAt: Datetime
  updatedAt: Datetime
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """A list of `User` objects."""
  nodes: [User!]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USERNAME_ASC
  USERNAME_DESC
  ROLE_ID_ASC
  ROLE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}
